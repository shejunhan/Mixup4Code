import javalang
import secrets
import random
import json
from nltk.corpus import wordnet
import os, random, re
import os, random
from shutil import copyfile
import ast
import wordninja
import re, random
from os import listdir
from os.path import isfile, join
from os import listdir
from os.path import isfile, join
import javalang
import secrets
import random
import json

from os import listdir
from os.path import isfile, join
import re, random
from nltk.corpus import wordnet
import wordninja
import os, random, re
import os, random
from shutil import copyfile
class  refactor_ruby(object):
    def __init__(self, *args, **kwargs): # real signature unknown
        pass
    def get_radom_var_name(self):
        res_string = ''
        for x in range(8):
            res_string += random.choice('abcdefghijklmnopqrstuvwxyz')
        return res_string


    def get_dead_for_condition(self):
        var = self.get_radom_var_name()
        return "int "+var+" = 0; "+var+" < 0; "+var+"++"


    def get_random_false_stmt(self):
        res = [random.choice(["true", "false"]) for x in range(10)]
        res.append("false")
        res_str = " && ".join(res)
        return res_str


    def get_tree(self,data):
        tokens = javalang.tokenizer.tokenize(data)
        parser = javalang.parser.Parser(tokens)
        tree = parser.parse_member_declaration()
        return tree


    def verify_method_syntax(self,data):
        try:
            tokens = javalang.tokenizer.tokenize(data)
            parser = javalang.parser.Parser(tokens)
            tree = parser.parse_member_declaration()
            print("syantax check passed")
        except:
            print("syantax check failed")


    def get_random_type_name_and_value_statment(self):
        datatype = random.choice(
            'byte,short,int,long,float,double,boolean,char,String'.split(','))
        var_name = self.get_radom_var_name()

        if datatype == "byte":
            var_value = self.get_random_int(-128, 127)
        elif datatype == "short":
            var_value = self.get_random_int(-10000, 10000)
        elif datatype == "boolean":
            var_value = random.choice(["true", "false"])
        elif datatype == "char":
            var_value = str(random.choice(
                'a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z'.split(',')))
            var_value = '"'+var_value+'"'
        elif datatype == "String":
            var_value = str(self.get_radom_var_name())
            var_value = '"'+var_value+'"'
        else:
            var_value = self.get_random_int(-1000000000, 1000000000)

        mutant = str(var_name) + ' = ' + str(var_value)
        return mutant


    def generate_file_name_list_file_from_dir(self,method_path):
        filenames = [f for f in listdir(
            method_path) if isfile(join(method_path, f))]
        with open(method_path+'\\'+'all_file_names.txt', 'w') as f:
            f.write(json.dumps(filenames))
        print("done")


    def get_file_name_list(self,method_path):
        with open(method_path+'\\'+'all_file_names.txt') as f:
            data = json.load(f)
        return data


    def get_random_int(self,min, max):
        return random.randint(min, max)


    def format_code_chuncks(self,code_chuncks):
        for idx, c in enumerate(code_chuncks):
            c = c.replace(' . ', '.')
            c = c.replace(' ( ', '(')
            c = c.replace(' ) ', ')')
            c = c.replace(' ;', ';')
            c = c.replace('[ ]', '[]')
            code_chuncks[idx] = c
        return code_chuncks


    def format_code(self,c):
        c = c.replace(' . ', '.')
        c = c.replace(' ( ', '(')
        c = c.replace(' ) ', ')')
        c = c.replace(' ;', ';')
        c = c.replace('[ ]', '[]')
        return c


    def get_method_header(self,string):
        method_header = ''
        tree = self.get_tree(string)
        # print("tree")

        tokens = list(javalang.tokenizer.tokenize(string))
        # print(tokens)
        chunck_start_poss = [s.position.column for s in tree.body]
        # print(chunck_start_poss)
        if len(chunck_start_poss) > 0:
            method_header = ' '.join([t.value for t in tokens
                                      if t.position.column < chunck_start_poss[0]])

        method_header = self.format_code_chuncks([method_header])[0]
        return method_header


    def get_method_statement(self,string):
        code_chuncks = []
        tree = self.get_tree(string)
        tokens = list(javalang.tokenizer.tokenize(string))
        chunck_start_poss = [s.position.column for s in tree.body]

        if len(chunck_start_poss) > 1:

            for idx, statement in enumerate(chunck_start_poss[:-1]):
                statment = ' '.join([t.value for t in tokens
                                     if t.position.column >= chunck_start_poss[idx]
                                     and t.position.column < chunck_start_poss[idx+1]])
                code_chuncks.append(statment)
            last_statment = ' '.join([t.value for t in tokens
                                      if t.position.column >= chunck_start_poss[-1]][:-1])
            code_chuncks.append(last_statment)

        if len(chunck_start_poss) == 1:
            last_statment = ' '.join([t.value for t in tokens
                                      if t.position.column >= chunck_start_poss[0]][:-1])
            code_chuncks.append(last_statment)
        code_chuncks = self.format_code_chuncks(code_chuncks)
        return code_chuncks


    def scan_tree(self,tree):
        for path, node in tree:
            print("=======================")
            print(node)


    def get_all_type(self,tree):
        res_list=[]
        for path, node in tree.filter(javalang.tree.ReferenceType):
            if node.name != None:
                res_list.append(node.name)
        return list(set(res_list))


    def scan_local_vars(self,tree):
        for path, node in tree.filter(javalang.tree.LocalVariableDeclaration):
            print("name=========type=============")
            print(node.declarators[0].name, "\t", node.type.name)


    def get_local_vars(self,tree):
        var_list = []
        for path, node in tree.filter(javalang.tree.LocalVariableDeclaration):
            var_list.append([node.declarators[0].name, node.type.name])

        return var_list


    def get_local_assignments(self,tree):
        var_list = []
        for path, node in tree.filter(javalang.tree.Assignment):
            var_list.append([node.declarators[0].name, node.type.name])
        return var_list


    def get_branch_if_else_mutant(self):
        a = self.get_random_type_name_and_value_statment()
        b = a.split('=')[0]
        mutant = ' if '+ '(' +self.get_random_false_stmt() + ') ' + a + ' else ' + b + '=' +str(self.get_random_int(-1000000000, 1000000000)) + ' end '
        return mutant


    def get_branch_if_mutant(self):
        mutant = 'if  '+self.get_random_false_stmt() + '  ' + \
            self.get_random_type_name_and_value_statment() + \
        '  end '
        return mutant


    def get_branch_while_mutant(self):
        mutant = 'while '+self.get_random_false_stmt() + '\n' + \
            self.get_random_type_name_and_value_statment() + \
        '  end '
        return mutant


    def get_branch_for_mutant(self):
        var = self.get_radom_var_name()
        mutant = 'for ' + var + ' in 0...0 do' + '\n' + self.get_random_type_name_and_value_statment() + '\n'+ ' end '
        return mutant

    def get_branch_case_mutant(self):
        var_name = self.get_radom_var_name()
        mutant =  var_name+' = 0  ' + \
            ' case '+var_name +\
            ' when 1 ' + \
                self.get_random_type_name_and_value_statment() + \
            ' else ' + \
                self.get_random_type_name_and_value_statment() + \
            ' end '
        return mutant
    reserved_kws = ["abstract", "assert", "boolean",
                    "break", "byte", "case", "catch", "char", "class", "const",
                    "continue", "default", "do", "double", "else", "extends", "false",
                    "final", "finally", "float", "for", "goto", "if", "implements",
                    "import", "instanceof", "int", "interface", "long", "native",
                    "new", "null", "package", "private", "protected", "public",
                    "return", "short", "static", "strictfp", "super", "switch",
                    "synchronized", "this", "throw", "throws", "transient", "true",
                    "try", "void", "volatile", "while"]

    reserved_cls = ["ArrayDeque", "ArrayList", "Arrays", "BitSet", "Calendar", "Collections", "Currency",
                    "Date", "Dictionary", "EnumMap", "EnumSet", "Formatter", "GregorianCalendar", "HashMap",
                    "HashSet", "Hashtable", "IdentityHashMap", "LinkedHashMap", "LinkedHashSet",
                    "LinkedList", "ListResourceBundle", "Locale", "Observable",
                    "PriorityQueue", "Properties", "PropertyPermission",
                    "PropertyResourceBundle", "Random", "ResourceBundle", "ResourceBundle.Control",
                    "Scanner", "ServiceLoader", "SimpleTimeZone", "Stack",
                    "StringTokenizer", "Timer", "TimerTask", "TimeZone",
                    "TreeMap", "TreeSet", "UUID", "Vector", "WeakHashMap"
                    ]

    reserved_kws = reserved_kws + reserved_cls


    def word_synonym_replacement(self, word):
        if len(word) <= 3:
            return word + '_new'
        word_set = wordninja.split(word)
        while True:
            if word_set == []:
                return word + '_new'
            word_tar = random.choice(word_set)
            word_syn = wordnet.synsets(word_tar)
            if word_syn == []:
                word_set.remove(word_tar)
            else:
                break
        word_ret = []
        for syn in word_syn:
            word_ret = word_ret + syn.lemma_names()
            if word_tar in word_ret:
                word_ret.remove(word_tar)
        try:
            word_new = random.choice(word_ret)
        except:
            word_new = word

        return word.replace(word_tar, word_new), word_ret


    def extract_method_name(self,string):
        match_ret = re.search('\w+\s*\(',string)
        if match_ret:
            method_name = match_ret.group()[:-1].strip()
            return method_name
        else:
            return None


    def extract_argument(self,string):
        end_pos    = string.find(')')
        # java那边原来的函数第一个{ 表示函数的内容已经开始了，第一个（表示现在开始写参数
        #end_pos    = string.find(')')
        #Python这边没有{，但是函数的形参都已（）来括起来    = string.find(')')
        # 提取范围是函数的第一行定义，一直到函数的内容
        sta_pas    = string.find('(')
        arguments  = string[sta_pas + 1 :end_pos+1].strip()[:-1]    # 从（ 一直提取到end，而且不包括end，把这个空字符去掉
        # 这边原版是arguments  = string[sta_pas + 1 :end_pos].strip()[:-1]  但是最后居然会少提取一个字符，所以我后面多加了一个1，居然对了
        arguments_list = arguments.split(',')
        if ' ' in arguments_list:
            arguments_list.remove(' ')
        if '' in arguments_list:
            arguments_list.remove('')
        return arguments_list

    def extract_brace_python(self,string, start_pos):
        fragment = string[start_pos:]
        line_list = fragment.split('\n')# 将一行一行代码作为元素传入这个列表，因为他以换行符为分界
        return_string = ''
        return_string += line_list[0] + '\n'      # 加入函数的定义也就是第一行
        space_min = 0
        for _ in range(1, len(line_list)):
            space_count = 0
            for char in line_list[_]:
                if char == ' ':
                    space_count += 1         # 一行代码的第一个字符是空格，计数加一，否则返回
                else:
                    break
            if _ == 1:
                space_min = space_count
                return_string += line_list[_] + '\n'
            elif space_count < space_min and space_count != len(line_list[_]):
                break
            else:
                return_string += line_list[_] + '\n'
        return_string = return_string[:-1]
        return return_string

    def extract_brace(self,string,start_pos):
        length = 0
        brace_l_num = 0
        brace_r_num = 0
        for char in string[start_pos:]:
            if char == '{':
                brace_l_num += 1
            if char == '}':
                brace_r_num += 1
            if brace_l_num == brace_r_num and brace_l_num > 0:
                break;
            length += 1
        return string[start_pos: start_pos + length + 1]

    '''
    def extract_import(string):
        import_list = re.findall('import .+;',string)
        return import_list,string
    '''


    def extract_class(self,string):

        class_list = []
        while ' class ' in string:
            start_pos  = string.find(' class ')
            class_text = self.extract_brace_ruby(string, start_pos)
            class_list.append(class_text)
            string = string.replace(class_text, '')

        while 'class ' in string:
            start_pos  = string.find('class ')
            class_text = self.extract_brace_ruby(string, start_pos)
            class_list.append(class_text)
            string = string.replace(class_text, '')

        return class_list, string

    def extract_function_ruby(self,string):
        i = 0
        function_list = []
        # print(string)
        while True:
            match_ret = re.search('def+\s*\w+\s*\(', string)
            # 这一行正则表达式是我后来改的
            # print(match_ret)
            if match_ret:
                function_head = match_ret.group()
                start_pos = string.find(function_head)
                function_text = self.extract_brace_ruby(string, start_pos)
                function_list.append(function_text)
                string = string.replace(function_text, 'vesal'+ str(i))
                i+=1
            else:
                break
        return function_list, string



    def extract_member_variable(self,string):

        variable_list = []
        while True:
            match_ret = re.search('(private|public).+;', string)
            if match_ret:
                variable_text = match_ret.group()
                variable_list.append(variable_text)
                string = string.replace(variable_text,'')
            else:
                break
        return variable_list,string


    def extract_function(self,string):
        i = 0
        function_list = []
        while True:
            match_ret = re.search('(protected|private|public).+\s*{', string)
            if match_ret:
                function_head = match_ret.group()
                start_pos = string.find(function_head)
                function_text = self.extract_brace(string, start_pos)
                function_list.append(function_text)
                string = string.replace(function_text, 'vesal'+ str(i))
                i+=1
            else:
                break
        return function_list, string


    def extract_for_loop(self,string):

        for_list = []
        while True:
            match_ret = re.search('for', string)
            if match_ret:
                for_head = match_ret.group()
                start_pos = string.find(for_head)
                for_text = self.extract_brace_ruby(string, start_pos)
                for_list.append(for_text)
                string = string.replace(for_text, '')
            else:
                break
        return for_list


    def extract_brace_ruby(self,string, start_pos):
        fragment = string[start_pos:]
        line_list = fragment.split('\n')# 将一行一行代码作为元素传入这个列表，因为他以换行符为分界
        return_string = ''
        return_string += line_list[0] + '\n'      # 加入函数的定义也就是第一行
        space_min = 0
        for _ in range(1, len(line_list)):
            space_count = 0
            for char in line_list[_]:
                if char == ' ':
                    space_count += 1         # 一行代码的第一个字符是空格，计数加一，否则返回
                else:
                    break
            if _ == 1:
                space_min = space_count
                return_string += line_list[_] + '\n'
            elif space_count < space_min and space_count != len(line_list[_]) :
                break
            else:
                return_string += line_list[_] + '\n'
        return_string = return_string[:-1]
        return return_string



    def extract_if(self,string):

        if_list = []
        while True:
            match_ret = re.search('if\s+\(', string)
            if match_ret:
                if_head = match_ret.group()
                start_pos = string.find(if_head)
                if_text = self.extract_brace(string, start_pos)
                if_list.append(if_text)
                string = string.replace(if_text, '')
            else:
                break
        return if_list

    def extract_if_ruby(self,string):

        if_list = []
        while True:
            match_ret = re.search(' if ', string)
            if match_ret:
                if_head = match_ret.group()
                start_pos = string.find(if_head)
                if_text = self.extract_brace_ruby(string, start_pos)
                if_list.append(if_text)
                string = string.replace(if_text, '')
            else:
                break
        return if_list


    def extract_while_loop(self,string):

        while_list = []
        while True:
            match_ret = re.search('while\s+\(', string)
            if match_ret:
                while_head = match_ret.group()
                start_pos = string.find(while_head)
                while_text = self.extract_brace(string, start_pos)
                while_list.append(while_text)
                string = string.replace(while_text, '')
            else:
                break
        return while_list, string


    def extract_local_variable(self,string):

        local_var_list = []
        statement_list = string.split('\n')
        for line in statement_list:
            match_ret = re.search('\w+\s*=', line)
            # 这里java正则表达式是'[^\s]+\s+\w+\s+='  形如int a = 1就能找到，没有找到的话就返回none
            # 这个赋值语句，我第一次改的时候写的是match_ret = re.search('\w+\s*=\s*\d+', line)，这个明显只能提取等号后面是整数的情况，但是明显太局限了
            # 我只需要一个等于号赋值就可以了，不需要后面的整数，所以我把后面的\d直接去掉了，这个是多此一举
            if match_ret:
                var_definition = match_ret.group()
                local_var_list.append(var_definition.split(' ')[0])
                # [0]返回的是int   [1]返回的是我想要的字符  [2]返回的是=   分别对应java的int counter = 1
#这个函数我改了正则表达式，改了取值的索引
        return local_var_list

    def rename_local_variable(self, method_string):
        local_var_list = self.extract_local_variable(method_string)
        if len(local_var_list) == 0:
            return method_string

        mutation_index = random.randint(0, len(local_var_list) - 1)
        return method_string.replace(local_var_list[mutation_index],self.word_synonym_replacement(local_var_list[mutation_index])[0])

    def add_local_variable(self,method_string):
        local_var_list = self.extract_local_variable(method_string)
        if len(local_var_list) == 0:
            return method_string

        mutation_index = random.randint(0, len(local_var_list) - 1)
        match_ret = re.search(local_var_list[mutation_index] + '=\w', method_string)
        if match_ret is None:
            match_ret = re.search(local_var_list[mutation_index] + ' = ', method_string)
        if match_ret is None:
            match_ret = re.search(local_var_list[mutation_index] + '= ', method_string)
        if match_ret:
            var_definition      = match_ret.group()[:-1]
            new_var_definition  = var_definition.replace(local_var_list[mutation_index], self.word_synonym_replacement(local_var_list[mutation_index])[0])
            method_string       = method_string.replace(var_definition, var_definition + '' + new_var_definition)
            return method_string
        else:
            return method_string


    def duplication(self,method_string):
        local_var_list = self.extract_local_variable(method_string)
        if len(local_var_list) == 0:
            return method_string
        mutation_index = random.randint(0, len(local_var_list) - 1)
        match_ret = re.search(local_var_list[mutation_index] + '=\w', method_string)
        if match_ret is None:
            match_ret = re.search(local_var_list[mutation_index] + ' = ', method_string)
        if match_ret is None:
            match_ret = re.search(local_var_list[mutation_index] + '= ', method_string)
        if match_ret:
            var_definition = match_ret.group()[:-1]
            new_var_definition = var_definition
            method_string = method_string.replace(var_definition, var_definition + new_var_definition)
            # print(method_string)
            return method_string
        else:
            # print(method_string)
            return method_string



    def rename_api(self,method_string):
        match_ret      = re.findall('\w+\s*\(', method_string)
        # 这边原来是 match_ret      = re.findall(' \s*\w+\s*\(', method_string)，这个正则表达式是检索不到任何值的
        if match_ret != []:
            api_name = random.choice(match_ret)[1:-1]
            return method_string.replace(api_name,self.word_synonym_replacement(api_name)[0])
        # word_synonym_replacement实现的功能顾名思义就是把原来的字符串替换掉，替换成新的随机生成的字符串
        else:
            return method_string


    def rename_method_name(self,method_string):
        method_name = self.extract_method_name(method_string)
        if method_name:
            return method_string.replace(method_name, self.word_synonym_replacement(method_name)[0])
        else:
            return method_string


    def rename_argument(self,method_string):
        arguments_list = self.extract_argument(method_string)
        # 提取出所有的函数变量的
        if len(arguments_list) == 0:
            return method_string

        mutation_index = random.randint(0, len(arguments_list) - 1)
        # print(self.word_synonym_replacement(arguments_list[mutation_index]))
        # print(method_string.replace(arguments_list[mutation_index],word_synonym_replacement(arguments_list[mutation_index])[0]))
        if(type(self.word_synonym_replacement(arguments_list[mutation_index]))== str ):
            return method_string.replace(arguments_list[mutation_index],self.word_synonym_replacement(arguments_list[mutation_index]))
        else:
            return method_string.replace(arguments_list[mutation_index],self.word_synonym_replacement(arguments_list[mutation_index])[0])
    # word_s……返回的是一个元组或者一个字符串，这个是由wordjne本身决定的我们改不了word_sy这个函数
    # 如果是('v0x*(-v1wye', ['yttrium', 'Y', 'atomic_number_39', 'Y', 'wye'])那我们明显只需要前面那个元素，所以说，后面一定要填一个0，不然就错的，怎么能将一个元组和一个字符进行互换呢？？？
    # return method_string.replace(arguments_list[mutation_index],self.word_synonym_replacement(arguments_list[mutation_index]))我就在后面填一个[0]
    # 如果是一个字符串，那不需要加0 直接写就行了



    def return_optimal(self,method_string):
        #改变的是return语句
        if 'return ' in method_string:
            return_statement  = method_string[method_string.find('return ') : method_string.find('\n', method_string.find('return ') + 1)]
            return_object     = return_statement.replace('return ','')
            # 找到函数语句中的return
            if return_object == 'nil':
                return method_string
            # 这代表没有返回语句，那也就自然不需要重构return代码
            optimal_statement = 'return ('  + return_object + ') || 0'
            # 为了避免出问题，这边我添加了括号
            # 这个是ruby里面的短路语句，如果写在ruby环境中，他代表如果return_object不为空，返回return_object，否则返回0
            #例如会返回这个式子return 0 if (i == None) else i，意思是说如果i等于none返回0，否则返回i
            # 本来是这么写的：'return 0 if (' + return_object + ' == None) else ' + return_object  如果是空返回0 ，否则返回原来的return后面的值
            method_string = method_string.replace(return_statement, optimal_statement)   # 这个replace大概代表重构
        return method_string

    def enhance_for_loop(self, method_string):
        for_loop_list = self.extract_for_loop(method_string)
        # kimi说ruby不常用for代码，但是我查看了测试代码，我发现for循环还是很常用的，而且它的for循环里面的迭代会加括号
        if for_loop_list == []:
            return method_string
        # 有了上面的这个return，然后才会有下面的随机取一个数字，要不然会报错(0,0,0)
        mutation_index = random.randint(0, len(for_loop_list) - 1)
        for_text = for_loop_list[mutation_index]
        # 这个for_test不是全部的for_test,他是在里面随机抽取一个for语句
        # print(for_text)
        for_info = for_text[for_text.find('(') +1: for_text.find(')')]
        # 提取第一个括号，那必然就是循环的条件了，我观察到正常来说的代码，for的条件也就是...都会加括号
        # print(for_info)
        # 提取for后面的参数
        if (('...' in for_text) or ('..' in for_text)):
            if (('.each' not in for_text) and ('.step' not in for_text)) :  # 既然在for_info 也就是for参数里面不可能匹配到.each 那我就在for的全部函数里面匹配，这个.each必然加在函数后面
                # 这边用and，两个都不在的情况
                new_for_info = '( ' + for_info + ') .step(1)'
                method_string = method_string.replace(for_info, new_for_info)
            else:
                new_for_info = for_info + '+0'
                # 这个for循环中有这个.each,那我就在后面多加一个0，比如2..s_max_p +0
                method_string = method_string.replace(for_info, new_for_info)
            return method_string

        else:
            return method_string


    def add_puts(self,method_string):
        statement_list = method_string.split('\n')
        mutation_index = random.randint(1, len(statement_list) - 1)
        statement      = statement_list[mutation_index]
        if statement == '':
            return method_string
        space_count = 0
        if mutation_index == len(statement_list) - 1:
            refer_line = statement_list[-1]
            for char in refer_line:
                if char == ' ':
                    space_count += 1
                else:
                    break
        else:
            refer_line = statement_list[mutation_index]
            for char in refer_line:
                if char == ' ':
                    space_count += 1
                else:
                    break
        new_statement = ''
        for _ in range(space_count):
            new_statement += ' '
        new_statement += 'puts "' + str(random.choice(self.word_synonym_replacement(statement)[1])) + '"'
        # 原本的print("作为以个整体的字符串用‘框起来，就是’print("‘,ruby这边不需要这个括号  原来的Python代码这边输出的就是一个字符，那么ruby这边我也让他输出一个字符串
        method_string = method_string.replace(statement, '\n' + new_statement + '\n' + statement)
        return method_string



    def enhance_if(self,method_string):
        if_list = self.extract_if_ruby(method_string)
        # 提取ruby代码中if的参数
        if (len(if_list)==0):
            return method_string
        # enhance_if 是if语句的条件增强，要是这行代码中都检测不到if语句，那自然也就直接返回这段代码了，就不存在什么if语句增强了
        mutation_index = random.randint(0, len(if_list) - 1 )
        if_text = if_list[mutation_index]
        if_info = if_text[if_text.find('if ') + 3: if_text.find('\n')]
        # ; 在ruby语言中表示不换行，所有的代码都堆在一起写
        # 原来的代码是这样的if_info = if_text[if_text.find('if ') + 3: if_text.find(':')]，它的作用是提取if语句中的condition
        # 第二次我改成了if_info = if_text[if_text.find('if ') + 3: max(if_text.find('\n'), if_text.find(';'))]也不太好用
        # 后来我又发现第二次不好用是因为第二次提取的是两个索引的最大值，而;这个东西不仅可能出现在if后面，还可能猫在其他地方，所以说，只能用\n提取
        # 第三次我写成了if_info = if_text[if_text.find('if ') + 3: if_text.find('\n')] 才提取到了想要的东西
        # 在Python中if条件说完了会用：但是在ruby中不会，它要么换行分成两行写，要么用;全都堆在一行写
        # .find方法针对于字符串，他能提取某一个字符对应的索引，我改成这样意思就是，\n ； 两个中间我必须要提取到其中的一个，这两个符号在我定位到if之后必然会存在一个，还有一个会返回-1，我只需要提取那个不等于-1的作为索引值就行
        new_if_info = if_info
        if 'true' in if_info:
            new_if_info = if_info.replace('true', ' (0==0) ')  # 相当于是语义的变换，比如true，我就要变换成0==0，意思确实没有变
        if 'flase' in if_info:
            new_if_info = if_info.replace('flase', ' (1==0) ')
        if '!=' in if_info and '(' not in if_info and 'and' not in if_info and 'or' not in if_info:
            new_if_info = '!' + if_info.split('!=')[0].strip() + '.equal?(' + if_info.split('!=')[1] + ')'
            # 按照!= 对原来提取到的内容进行划分，取[0],[1]作为两个元素
        if '<' in if_info and '<=' not in if_info and '(' not in if_info and 'and' not in if_info and 'or' not in if_info:
            new_if_info = if_info.split('<')[1] + ' > ' + if_info.split('<')[0]
            # 把><左右两边交换，然后变号
        if '>' in if_info and '>=' not in if_info and '(' not in if_info and 'and' not in if_info and 'or' not in if_info:
            new_if_info = if_info.split('>')[1] + ' < ' + if_info.split('>')[0]
        if '<=' in if_info and '(' not in if_info and 'and' not in if_info and 'or' not in if_info:
            new_if_info = if_info.split('<=')[1] + ' >= ' + if_info.split('<=')[0]
        if '>=' in if_info and '(' not in if_info and 'and' not in if_info and 'or' not in if_info:
            new_if_info = if_info.split('>=')[1] + ' <= ' + if_info.split('>=')[0]
        if '==' in if_info:
            new_if_info = if_info.split('==')[0].strip() + '.equal?(' + if_info.split('==')[1] + ')'
        return method_string.replace(if_info, new_if_info)


    def add_argumemts(self,method_string):
        arguments_list = self.extract_argument(method_string)
        # 这第一行就注定了只能提取到def里面的变量
        arguments_info = method_string[method_string.find('(') + 1: method_string.find(')')]
        if len(arguments_list) == 0:
            arguments_info = self.word_synonym_replacement(self.extract_method_name(method_string))[0]
            return method_string[0 : method_string.find('()') + 1] + arguments_info + method_string[method_string.find('()') + 1 :]
        mutation_index = random.randint(0, len(arguments_list) - 1)
        # 所以这个代码不会出现（0,0,0）的问题，如果是一个参数的话，那这个随机的值就是0，因为在0到0就0一个数
        org_argument = arguments_list[mutation_index]
        new_argument = self.word_synonym_replacement(arguments_list[mutation_index])
        # 说明这个new_argument很可能是元组，这个word_synonym_replacement有些时候生成的就是元组，模仿rename_argument的改法
        if(type(new_argument)==str):
            new_arguments_info = arguments_info.replace(org_argument, org_argument + ', ' + new_argument)
            method_string = method_string.replace(arguments_info, new_arguments_info, 1)
            return method_string
        else:
            new_arguments_info =  arguments_info.replace(org_argument, org_argument + ', ' + new_argument[0])
            method_string = method_string.replace(arguments_info, new_arguments_info, 1)
            return method_string


    def enhance_filed(self,method_string):
        # 对其中一个形参进行检查，例如if seq == nil puts('please check your input')  end 添加这一行内容
        arguments_list = self.extract_argument(method_string)
        # 获取函数内的形参
        line_list = method_string.split('\n')
        refer_line = line_list[1]
        # 获取的是函数除了定义以外的第一行代码
        if len(arguments_list) == 0:
            return method_string
        space_count = 0
        for char in refer_line:
            if char == ' ':
                space_count += 1
            else:
                break
        mutation_index = random.randint(0, len(arguments_list) - 1)
        # 随机序列
        space_str = ''
        for _ in range(space_count):
            space_str += ' '
        extra_info = "\n" + space_str + "if " + arguments_list[mutation_index].strip().split(' ')[-1] + " == nil puts('please check your input')   end " + '\n'
        # 上面这一行只是获取多余的参数，函数添加内容在def之前和上面这一行代码无关
        # 出现这种情况和下面这行代码的组合有很大的关系
        method_string = method_string[0 : method_string.find(')') + 1] + extra_info + method_string[method_string.find(')') + 1 : ]
        # python函数形参结束的标志是:   既然ruby里面我们虽然不用这个作为函数结束的标志，但是我们总要写括号把，右括号肯定是函数结束的条件吧
        return method_string




    def apply_plus_zero_math(self,data):
        variable_list = self.extract_local_variable(data)
        success_flag = 0
        for variable_name in variable_list:
            match_ret = re.findall(variable_name + '\s*=\s\w*\n', data)
            if len(match_ret) > 0:
                code_line = match_ret[0]
                value = code_line.split('\n')[0].split('=')[1]
                ori_value = value
                if '+' in value or '-' in value or '*' in value or '/' in value or '//' in value:
                    value = value + ' + 0'
                    success_flag = 1
                try:
                    value_float = float(value)
                    value = value + ' + 0'
                    success_flag = 1
                except ValueError:
                    continue
                if success_flag == 1:
                    mutant = code_line.split(ori_value)[0]
                    mutant = mutant + value + '\n'
                    method_string = data.replace(code_line, mutant)
                    return method_string
        if success_flag == 0:
            return data




# dead这边一堆基本上都是在里面插入一个函数，这个函数的格式就是遵循get_branch里面写的格式，那个里面的我已经换过了，这个dead里面由于切分的方式和Python几乎一致所以说不需要另外改
    def dead_branch_if_else(self,data):
        statement_list = data.split('\n')
        mutation_index = random.randint(1, len(statement_list) - 1)
        statement = statement_list[mutation_index]
        space_count = 0
        # 计算缩进数，也就是前面的空格数
        if statement == '':
            return data
        if mutation_index == len(statement_list) - 1:
            refer_line = statement_list[-1]
            for char in refer_line:
                if char == ' ':
                    space_count += 1
                else:
                    break
        else:
            refer_line = statement_list[mutation_index]
            for char in refer_line:
                if char == ' ':
                    space_count += 1
                else:
                    break
        new_statement = ''
        for _ in range(space_count):
            new_statement += ' '
        new_statement += self.get_branch_if_else_mutant()
        method_string = data.replace(statement, '\n' + new_statement + '\n' + statement)
        return method_string




    def dead_branch_if(self,data):
        statement_list = data.split('\n')
        mutation_index = random.randint(1, len(statement_list) - 1)
        statement = statement_list[mutation_index]
        space_count = 0
        if statement == '':
            return data
        if mutation_index == len(statement_list) - 1:
            refer_line = statement_list[-1]
            for char in refer_line:
                if char == ' ':
                    space_count += 1
                else:
                    break
        else:
            refer_line = statement_list[mutation_index]
            for char in refer_line:
                if char == ' ':
                    space_count += 1
                else:
                    break
        new_statement = ''
        for _ in range(space_count):
            new_statement += ' '
        new_statement += self.get_branch_if_mutant()
        method_string = data.replace(statement, '\n' + new_statement + '\n' + statement)

        return method_string



    def dead_branch_while(self,data):
        statement_list = data.split('\n')
        mutation_index = random.randint(1, len(statement_list) - 1)
        statement = statement_list[mutation_index]
        space_count = 0
        if statement == '':
            return data
        if mutation_index == len(statement_list) - 1:
            refer_line = statement_list[-1]
            for char in refer_line:
                if char == ' ':
                    space_count += 1
                else:
                    break
        else:
            refer_line = statement_list[mutation_index]
            for char in refer_line:
                if char == ' ':
                    space_count += 1
                else:
                    break
        new_statement = ''
        for _ in range(space_count):
            new_statement += ' '
        new_statement += self.get_branch_while_mutant()
        method_string = data.replace(statement, '\n' + new_statement + '\n' + statement)
        # print(method_string)
        return method_string


    def dead_branch_for(self,data):
        statement_list = data.split('\n')
        mutation_index = random.randint(1, len(statement_list) - 1)
        statement = statement_list[mutation_index]
        space_count = 0
        if statement == '':
            return data
        if mutation_index == len(statement_list) - 1:
            refer_line = statement_list[-1]
            for char in refer_line:
                if char == ' ':
                    space_count += 1
                else:
                    break
        else:
            refer_line = statement_list[mutation_index]
            for char in refer_line:
                if char == ' ':
                    space_count += 1
                else:
                    break
        new_statement = ''
        for _ in range(space_count):
            new_statement += ' '
        new_statement += self.get_branch_for_mutant()
        method_string = data.replace(statement, '\n' + new_statement + '\n' + statement)
        return method_string



    def dead_branch_case(self,data):
        statement_list = data.split('\n')
        mutation_index = random.randint(1, len(statement_list) - 1)
        statement = statement_list[mutation_index]
        space_count = 0
        if statement == '':
            return data
        if mutation_index == len(statement_list) - 1:
            refer_line = statement_list[-1]
            for char in refer_line:
                if char == ' ':
                    space_count += 1
                else:
                    break
        else:
            refer_line = statement_list[mutation_index]
            for char in refer_line:
                if char == ' ':
                    space_count += 1
                else:
                    break
        new_statement = ''
        for _ in range(space_count):
            new_statement += ' '
        new_statement += self.get_branch_case_mutant()
        method_string = data.replace(statement, '\n' + new_statement + '\n' + statement)
        return method_string



    def return_function_code(self,code, method_names):
    # 应该是我改的最久的函数之一，建议与之连带的几个函数全都去检查一遍,真是一块硬骨头，但是我有预感，这个不见得很难改，因为就少一个end
        final_codes = []
        final_names = []
        Class_list, raw_code = self.extract_class(code)
        for class_name in Class_list:
            function_list, class_name = self.extract_function_ruby(class_name)
        for fun_code in function_list:
            for method_name in method_names:
                method_name_tem = method_name.replace('|', '')

                if method_name_tem.upper() in fun_code.split('\n')[0].upper():

                    final_codes.append(fun_code)   # 就是少一个end
                    final_names.append(method_name)
        return final_codes, final_names


    def generate_adversarial(self,k, code, method_names):

            method_name = method_names[0]
            function_list = []
            class_name = ''

            Class_list, raw_code = self.extract_class(code)

            for class_name in Class_list:
                function_list, class_name = self.extract_function(class_name)

            refac = []
            new_refactored_code = ''

            for code in function_list:
                if method_name not in code.split('\n')[0]:
                    continue

                new_rf = code
                new_refactored_code = code

                # print(code)
                for t in range(k):
                    refactors_list = [self.rename_argument,
                                      self.return_optimal,
                                      self.add_argumemts,
                                      self.rename_api,
                                      self.rename_local_variable,
                                      self.add_local_variable,
                                      self.rename_method_name,
                                      self.enhance_if,
                                      self.add_puts,
                                      self.duplication,
                                      self.apply_plus_zero_math,
                                      self.dead_branch_if_else,
                                      self.dead_branch_if,
                                      self.dead_branch_while,
                                      self.dead_branch_for,
                                      # self.dead_branch_switch
                                      ]#

                    vv = 0

                    while new_rf == new_refactored_code and vv <= 20:
                        try:
                            vv += 1

                            refactor       = random.choice(refactors_list)
                            print('*'*50 , refactor , '*'*50)
                            new_refactored_code = refactor(new_refactored_code)

                        except Exception as error:
                            print('error:\t', error)

                    new_rf = new_refactored_code

                    print('----------------------------OUT of WHILE----------------------------------', vv)
                    print('----------------------------CHANGED THJIS TIME:----------------------------------', vv)

                refac.append(new_refactored_code)

            code_body = raw_code.strip() + ' ' + class_name.strip()
            for i in range(len(refac)):
                final_refactor = code_body.replace('vesal' + str(i), str(refac[i]))
                code_body = final_refactor


            return new_refactored_code


    def generate_adversarial_json(self,k, code):
        final_refactor = ''
        function_list = []
        class_name = ''
        vv = 0
        if len(function_list) == 0:
            function_list.append(code)
        refac = []
        for code in function_list:


            new_rf = code
            new_refactored_code = code

            for t in range(k):

                refactors_list = [self.rename_argument,
                                  self.return_optimal,
                                  self.add_argumemts,
                                  self.rename_api,
                                  self.rename_local_variable,
                                  self.add_local_variable,
                                  self.rename_method_name,
                                  self.enhance_if,
                                  self.add_puts,
                                  self.duplication,
                                  self.apply_plus_zero_math,
                                  self.dead_branch_if_else,
                                  self.dead_branch_if,
                                  self.dead_branch_while,
                                  self.dead_branch_for,
                                  self.dead_branch_case
                                  ]

                vv = 0

                while new_rf == new_refactored_code and vv <= 20:
                    try:
                        vv += 1
                        refactor = random.choice(refactors_list)
                        print('*' * 50, refactor, '*' * 50)
                        new_refactored_code = refactor(new_refactored_code)

                    except Exception as error:
                        print('error:\t', error)

                new_rf = new_refactored_code

            refac.append(new_refactored_code)

        print("refactoring finished")
        return refac


    def generate_adversarial_file_level(self,k, code):
            new_refactored_code = ''
            new_rf = code
            new_refactored_code = code

            for t in range(k):
                refactors_list = [self.rename_argument,
                                  self.return_optimal,
                                  self.add_argumemts,
                                  self.rename_api,
                                  self.rename_local_variable,
                                  self.add_local_variable,
                                  self.rename_method_name,
                                  self.enhance_if,
                                  self.add_puts,
                                  self.duplication,
                                  self.apply_plus_zero_math,
                                  self.dead_branch_if_else,
                                  self.dead_branch_if,
                                  self.dead_branch_while,
                                  self.dead_branch_for,
                                  self.dead_branch_case
                                  ]

                vv = 0

                while new_rf == new_refactored_code and vv <= 20:
                    try:
                        vv += 1
                        refactor = random.choice(refactors_list)
                        print('*' * 50, refactor, '*' * 50)
                        new_refactored_code = refactor(new_refactored_code)

                    except Exception as error:
                        print('error:\t', error)

                new_rf = new_refactored_code

            return new_refactored_code
# if __name__ == '__main__':
#     K = 1
#     filename = 'ruby_test.py'
#     open_file = open(filename, 'r', encoding='ISO-8859-1')
#     code = open_file.read()
#     new_code=refactor_ruby()
#     print(new_code.generate_adversarial_file_level(K,code))
